#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"

#include "esp_log.h"
#include "esp_system.h"
#include "esp_freertos_hooks.h"
#include "esp_heap_caps.h"
#include "driver/spi_master.h"
#include "driver/i2c.h"

#include "lvgl.h"
#include "lvgl_helpers.h"

#include <cstdio>
#include <string>

#include "bq40z80.h"
#include "ui.h"
/*-----------------函数声明-----------------------------------*/
static void lvgl_test(void);
void my_timer(lv_timer_t *timer);
lv_obj_t *label1;
lv_obj_t *label2;
lv_obj_t *label3;
uint16_t bq40z80_voltage;
uint16_t bq40z80_current;
uint16_t bq40z80_fcc;
uint16_t bq40z80_capacity;
uint16_t bq40z80_rsoc;
/*-----------------------------------------------------------*/

/* LVGL 移植部分 */
static void lv_tick_task(void *arg)
{
    (void)arg;
    lv_tick_inc(portTICK_PERIOD_MS);
}
SemaphoreHandle_t xGuiSemaphore;

/* UI 任务 */
static void gui_task(void *arg)
{
    xGuiSemaphore = xSemaphoreCreateMutex();
    lv_init();          // lvgl内核初始化
    lvgl_driver_init(); // lvgl显示接口初始化

    static lv_disp_draw_buf_t draw_buf;
    lv_color_t *buf1 = reinterpret_cast<lv_color_t *>(heap_caps_malloc(LV_HOR_RES_MAX * LV_VER_RES_MAX * sizeof(lv_color_t), MALLOC_CAP_DMA));
    lv_color_t *buf2 = reinterpret_cast<lv_color_t *>(heap_caps_malloc(LV_HOR_RES_MAX * LV_VER_RES_MAX * sizeof(lv_color_t), MALLOC_CAP_DMA));
    lv_disp_draw_buf_init(&draw_buf, buf1, buf2, LV_HOR_RES_MAX * LV_VER_RES_MAX); /*Initialize the display buffer*/

    static lv_disp_drv_t disp_drv;         /*A variable to hold the drivers. Must be static or global.*/
    lv_disp_drv_init(&disp_drv);           /*Basic initialization*/
    disp_drv.draw_buf = &draw_buf;         /*Set an initialized buffer*/
    disp_drv.flush_cb = disp_driver_flush; /*Set a flush callback to draw to the display*/
    disp_drv.hor_res = 160;                /*Set the horizontal resolution in pixels*/
    disp_drv.ver_res = 80;                 /*Set the vertical resolution in pixels*/
    lv_disp_drv_register(&disp_drv);       /*Register the driver and save the created display objects*/
    esp_register_freertos_tick_hook(reinterpret_cast<esp_freertos_tick_cb_t>(lv_tick_task));

    lvgl_test();

    lv_timer_t *timer = lv_timer_create(my_timer, 1000, 0);
    while (1)
    {
        /* Delay 1 tick (assumes FreeRTOS tick is 10ms */
        vTaskDelay(pdMS_TO_TICKS(10));

        /* Try to take the semaphore, call lvgl related function on success */
        if (pdTRUE == xSemaphoreTake(xGuiSemaphore, portMAX_DELAY))
        {
            lv_timer_handler();
            xSemaphoreGive(xGuiSemaphore);
        }
    }
}

// lvgl测试
static void lvgl_test(void)
{

    label1 = lv_label_create(lv_scr_act());
    lv_label_set_long_mode(label1, LV_LABEL_LONG_WRAP);
    lv_label_set_recolor(label1, true);
    lv_label_set_text(label1, "Voltage:");
    lv_obj_set_width(label1, 140);
    lv_obj_set_style_text_align(label1, LV_TEXT_ALIGN_LEFT, 0);
    lv_obj_align(label1, LV_ALIGN_CENTER, 0, -25);

    label2 = lv_label_create(lv_scr_act());
    lv_label_set_long_mode(label2, LV_LABEL_LONG_WRAP);
    lv_label_set_recolor(label2, true);
    lv_label_set_text(label2, "Current:");
    lv_obj_set_width(label2, 140);
    lv_obj_set_style_text_align(label2, LV_TEXT_ALIGN_LEFT, 0);
    lv_obj_align(label2, LV_ALIGN_CENTER, 0, -10);

    label3 = lv_label_create(lv_scr_act());
    lv_label_set_long_mode(label3, LV_LABEL_LONG_WRAP);
    lv_label_set_recolor(label3, true);
    lv_label_set_text(label3, "");
    lv_obj_set_width(label3, 140);
    lv_obj_set_style_text_align(label3, LV_TEXT_ALIGN_LEFT, 0);
    lv_obj_align(label3, LV_ALIGN_CENTER, 0, 20);

    // lv_obj_t *label2 = lv_label_create(lv_scr_act());
    // lv_label_set_long_mode(label2, LV_LABEL_LONG_SCROLL_CIRCULAR); /*Circular scroll*/
    // lv_obj_set_width(label2, 120);
    // lv_label_set_text(label2, "It is a circularly scrolling text. ");
    // lv_obj_align(label2, LV_ALIGN_CENTER, 0, 30);
}

void my_timer(lv_timer_t *timer)
{
    char buf[64];
    sprintf(buf, "Voltage: %.3f V", (float)bq40z80_voltage / 1000);
    lv_label_set_text(label1, buf);
    sprintf(buf, "Current: %.2f A", (float)bq40z80_current / 1000);
    lv_label_set_text(label2, buf);

    sprintf(buf, "%d/%dmAh %d%%", bq40z80_capacity, bq40z80_capacity, bq40z80_rsoc);
    lv_label_set_text(label3, buf);
}

#define TAG "bq40z80_test"
void i2c_test_task(void *arg)
{
    ESP_LOGI(TAG, "Initlizing I2C");
    auto device = BQ40Z80(10, 11, I2C_NUM_0);
    ESP_LOGI(TAG, "Done");

    bq40z80_fcc = device.get_fcc();
    while (1)
    {
        vTaskDelay(pdMS_TO_TICKS(1000));
        bq40z80_voltage = device.get_voltage();
        bq40z80_current = device.get_current();
        bq40z80_capacity = device.get_remaining_capacity();
        bq40z80_rsoc = device.get_rsoc();
        // ESP_LOGI(TAG, "Voltage: %d mV", device.get_voltage());
        // ESP_LOGI(TAG, "Current: %d mA", device.get_current());
        // ESP_LOGI(TAG, "Remaining Capacity: %d mAh", device.get_remaining_capacity());
        // ESP_LOGI(TAG, "FCC: %d mAh", device.get_fcc());
    }
}

// 主函数
extern "C" void app_main(void)
{
    xTaskCreatePinnedToCore(gui_task, "gui task", 1024 * 3, NULL, 1, NULL, 0);
    xTaskCreatePinnedToCore(i2c_test_task, "i2c test task", 1024 * 3, NULL, 2, NULL, 0);
}
